---
layout:     post
title:      python中的列表(list)复制
date:       2019-09-27
author:     zlh
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 编程
---

#### 前言
在python的列表复制上踩过两次坑，事不过三，打算写一篇文章，
简单总结一下这个问题。

简言之，python的列表复制可分为以下三类：假拷贝、浅拷贝、深拷贝。


#### 假拷贝 

```python
>> b = [1,2]
>> a = b
>> a[0] = 0
>> print(b)
[0,2]

```
python当中，可变对象的赋值(=)是通过变量名【重新指向】内存空间完成的，
而非【创建】新内存空间。
所以，上述代码中，在执行到`a = b`后，变量名a、b会指向同一块内存区域，因此当a中的值改变时，
b中的值也会改变。

由于这种赋值（=）操作无法做到真正的列表拷贝，姑且称之为【假拷贝】。

#### 浅拷贝
为了开辟新的内存区域进行赋值，可利用list的copy()方法：
``` python
>>> b = [1,2]
>>> a = b.copy()
>>> a[0] = 0
>>> a
[0, 2]
>>> b
[1,2]
```
但若列表中包含【可变对象】，常见情况如嵌套列表(nested list)，
则【该可变对象】的复制依旧是通过【重新指向】而非【创建】内存区域实现的 (因此依旧是假拷贝）。
其他【不可变元素】依旧能够正常copy:
``` python
>>> b = [[1],2]
>>> a = b.copy()
>>> a[0][0] = 0
>>> a[1] = 0
>>> a
[[0], 0]
>>> b
[[0],2]
```

可见，利用copy()方法复制列表，当遇到嵌套列表时依旧无法
做到真正的复制。


#### 深拷贝
为了解决嵌套列表的复制问题，需要使用copy模块的deepcopy()方法：

``` python
>>> from copy import deepcopy
>>> b = [[1],2]
>>> a = deepcopy(b)
>>> a[0][0] = 0
>>> a
[[0], 2]
>>> b
[[1],2]
```

Done!
